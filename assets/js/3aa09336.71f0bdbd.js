"use strict";(self.webpackChunkhongstack_docs=self.webpackChunkhongstack_docs||[]).push([[592],{3905:(e,a,t)=>{t.d(a,{Zo:()=>p,kt:()=>m});var n=t(7294);function s(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){s(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,s=function(e,a){if(null==e)return{};var t,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(s[t]=e[t]);return s}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var o=n.createContext({}),c=function(e){var a=n.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},p=function(e){var a=c(e.components);return n.createElement(o.Provider,{value:a},e.children)},u={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},d=n.forwardRef((function(e,a){var t=e.components,s=e.mdxType,r=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),m=s,b=d["".concat(o,".").concat(m)]||d[m]||u[m]||r;return t?n.createElement(b,i(i({ref:a},p),{},{components:t})):n.createElement(b,i({ref:a},p))}));function m(e,a){var t=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var r=t.length,i=new Array(r);i[0]=d;var l={};for(var o in a)hasOwnProperty.call(a,o)&&(l[o]=a[o]);l.originalType=e,l.mdxType="string"==typeof e?e:s,i[1]=l;for(var c=2;c<r;c++)i[c]=t[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9937:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var n=t(7462),s=(t(7294),t(3905));const r={sidebar_label:"Sealed Classes"},i="Java Sealed Classes",l={unversionedId:"Java/sealed-classes",id:"Java/sealed-classes",title:"Java Sealed Classes",description:"Sealed Classes and Interfaces in Java 15",source:"@site/docs/Java/sealed-classes.md",sourceDirName:"Java",slug:"/Java/sealed-classes",permalink:"/docs/Java/sealed-classes",draft:!1,editUrl:"https://github.com/hongstack/hongstack-docs/edit/main/docs/Java/sealed-classes.md",tags:[],version:"current",frontMatter:{sidebar_label:"Sealed Classes"},sidebar:"defaultSidebar",previous:{title:"Preface",permalink:"/docs/"}},o={},c=[{value:"Overview",id:"overview",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Modeling Possibilities",id:"modeling-possibilities",level:3},{value:"The Package-Private Approach",id:"the-package-private-approach",level:3},{value:"Superclass Accessible, Not Extensible",id:"superclass-accessible-not-extensible",level:3},{value:"Creation",id:"creation",level:2},{value:"Sealed Interfaces",id:"sealed-interfaces",level:3},{value:"Sealed Classes",id:"sealed-classes",level:3},{value:"Constraints",id:"constraints",level:2}],p={toc:c};function u(e){let{components:a,...t}=e;return(0,s.kt)("wrapper",(0,n.Z)({},p,t,{components:a,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"java-sealed-classes"},"Java Sealed Classes"),(0,s.kt)("p",null,"Sealed Classes and Interfaces in Java 15"),(0,s.kt)("h2",{id:"overview"},"Overview"),(0,s.kt)("p",null,"The release of Java SE 15 introduces sealed classes (JEP 360) as a preview feature."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"This feature is about enabling more fine-grained inheritance control in Java. Sealing allows classes and interfaces to define their permitted subtypes"),"."),(0,s.kt)("p",null,"In other words, a class or an interface can now define which classes can implement or extend it. It is a useful feature for domain modeling and increasing the security of libraries."),(0,s.kt)("h2",{id:"motivation"},"Motivation"),(0,s.kt)("p",null,"A class hierarchy enables us to reuse code via inheritance. However, the class hierarchy can also have other purposes. Code reuse is great but is not always our primary goal."),(0,s.kt)("h3",{id:"modeling-possibilities"},"Modeling Possibilities"),(0,s.kt)("p",null,"An alternative purpose of a class hierarchy can be to model various possibilities that exist in a domain."),(0,s.kt)("p",null,"As an example, imagine a business domain that only works with cars and trucks, not motorcycles. When creating the Vehicle abstract class in Java, we should be able to allow only Car and Truck classes to extend it. In that way, we want to ensure that there will be no misuse of the Vehicle abstract class within our domain."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"In this example, we are more interested in the clarity of code handling known subclasses than defending against all unknown subclasses"),"."),(0,s.kt)("p",null,"Before version 15, Java assumed that code reuse is always a goal. Every class was extendable by any number of subclasses."),(0,s.kt)("h3",{id:"the-package-private-approach"},"The Package-Private Approach"),(0,s.kt)("p",null,"In earlier versions, Java provided limited options in the area of inheritance control."),(0,s.kt)("p",null,"A ",(0,s.kt)("a",{parentName:"p",href:"https://www.baeldung.com/java-final"},"final class")," can have no subclasses. A ",(0,s.kt)("a",{parentName:"p",href:"https://www.baeldung.com/java-access-modifiers"},"package-private class")," can only have subclasses in the same package."),(0,s.kt)("p",null,"Using the package-private approach, users cannot access the abstract class without also allowing them to extend it:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public class Vehicles {\n    abstract static class Vehicle {\n        private final String registrationNumber;\n\n        public Vehicle(String registrationNumber) {\n            this.registrationNumber = registrationNumber;\n        }\n\n        public String getRegistrationNumber() {\n            return registrationNumber;\n        }\n    }\n\n    public static final class Car extends Vehicle {\n        private final int numberOfSeats;\n\n        public Car(int numberOfSeats, String registrationNumber) {\n            super(registrationNumber);\n            this.numberOfSeats = numberOfSeats;\n        }\n\n        public int getNumberOfSeats() {\n            return numberOfSeats;\n        }\n    }\n\n    public static final class Truck extends Vehicle {\n        private final int loadCapacity;\n\n        public Truck(int loadCapacity, String registrationNumber) {\n            super(registrationNumber);\n            this.loadCapacity = loadCapacity;\n        }\n\n        public int getLoadCapacity() {\n            return loadCapacity;\n        }\n    }\n}\n")),(0,s.kt)("h3",{id:"superclass-accessible-not-extensible"},"Superclass Accessible, Not Extensible"),(0,s.kt)("p",null,"A superclass that is developed with a set of its subclasses should be able to document its intended usage, not constrain its subclasses. Also, having restricted subclasses should not limit the accessibility of its superclass."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Thus, the main motivation behind sealed classes is to have the possibility for a superclass to be widely accessible but not widely extensible"),"."),(0,s.kt)("h2",{id:"creation"},"Creation"),(0,s.kt)("p",null,"The sealed feature introduces a couple of new modifiers and clauses in Java: ",(0,s.kt)("em",{parentName:"p"},"sealed"),", ",(0,s.kt)("em",{parentName:"p"},"non-sealed"),", and ",(0,s.kt)("em",{parentName:"p"},"permits"),"."),(0,s.kt)("h3",{id:"sealed-interfaces"},"Sealed Interfaces"),(0,s.kt)("p",null,"To seal an interface, we can apply the sealed modifier to its declaration. The ",(0,s.kt)("em",{parentName:"p"},"permits")," clause then specifies the classes that are permitted to implement the sealed interface:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java",metastring:"{1}","{1}":!0},"public sealed interface Service permits Car, Truck {\n    int getMaxServiceIntervalInMonths();\n\n    default int getMaxDistanceBetweenServicesInKilometers() {\n        return 100000;\n    }\n}\n")),(0,s.kt)("h3",{id:"sealed-classes"},"Sealed Classes"),(0,s.kt)("p",null,"Similar to interfaces, we can seal classes by applying the same ",(0,s.kt)("em",{parentName:"p"},"sealed")," modifier. The ",(0,s.kt)("em",{parentName:"p"},"permits")," clause should be defined after any ",(0,s.kt)("em",{parentName:"p"},"extends")," or ",(0,s.kt)("em",{parentName:"p"},"implements")," clauses:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public abstract sealed class Vehicle permits Car, Truck {\n    protected final String registrationNumber;\n\n    public Vehicle(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public String getRegistrationNumber() {\n        return registrationNumber;\n    }\n\n}\n")),(0,s.kt)("p",null,"A permitted subclass must define a modifier. It may be ",(0,s.kt)("a",{parentName:"p",href:"https://www.baeldung.com/java-final"},"declared final")," to prevent any further extensions:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public final class Truck extends Vehicle implements Service {\n    private final int loadCapacity;\n\n    public Truck(int loadCapacity, String registrationNumber) {\n        super(registrationNumber);\n        this.loadCapacity = loadCapacity;\n    }\n\n    public int getLoadCapacity() {\n        return loadCapacity;\n    }\n\n    @Override\n    public int getMaxServiceIntervalInMonths() {\n        return 18;\n    }\n}\n")),(0,s.kt)("p",null,"A permitted subclass may also be declared ",(0,s.kt)("em",{parentName:"p"},"sealed"),". However, if we declare it ",(0,s.kt)("em",{parentName:"p"},"non-sealed"),", then it is open for extension:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public non-sealed class Car extends Vehicle implements Service {\n    private final int numberOfSeats;\n\n    public Car(int numberOfSeats, String registrationNumber) {\n        super(registrationNumber);\n        this.numberOfSeats = numberOfSeats;\n    }\n\n    public int getNumberOfSeats() {\n        return numberOfSeats;\n    }\n\n    @Override\n    public int getMaxServiceIntervalInMonths() {\n        return 12;\n    }\n}\n")),(0,s.kt)("h2",{id:"constraints"},"Constraints"),(0,s.kt)("p",null,"A sealed class imposes three important constraints on its permitted subclasses:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"All permitted subclasses must belong to the same module as the sealed class."),(0,s.kt)("li",{parentName:"ol"},"Every permitted subclass must explicitly extend the sealed class."),(0,s.kt)("li",{parentName:"ol"},"Every permitted subclass must define a modifier: ",(0,s.kt)("em",{parentName:"li"},"final"),", ",(0,s.kt)("em",{parentName:"li"},"sealed"),", or ",(0,s.kt)("em",{parentName:"li"},"non-sealed"),".")))}u.isMDXComponent=!0}}]);